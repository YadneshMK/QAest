const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const lockfile = require('proper-lockfile');
const rateLimit = require('express-rate-limit');

// JWT Secret - In production, use environment variable
const JWT_SECRET = process.env.JWT_SECRET || 'qaest-secret-key-change-in-production';
const JWT_EXPIRY = '24h';

const app = express();

// CORS configuration
const corsOptions = {
  origin: function (origin, callback) {
    // Allow requests with no origin (like mobile apps or curl requests)
    if (!origin) return callback(null, true);
    
    const allowedOrigins = [
      'http://localhost:3000',
      'https://coruscating-custard-0291e7.netlify.app',
      /\.netlify\.app$/  // Allow any Netlify subdomain
    ];
    
    const isAllowed = allowedOrigins.some(allowed => {
      if (allowed instanceof RegExp) {
        return allowed.test(origin);
      }
      return allowed === origin;
    });
    
    if (isAllowed) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
};

// Rate limiting configurations
const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.',
  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
  legacyHeaders: false, // Disable the `X-RateLimit-*` headers
});

const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // Limit each IP to 5 requests per windowMs for auth endpoints
  message: 'Too many authentication attempts, please try again later.',
  skipSuccessfulRequests: true, // Don't count successful requests
});

const createLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 20, // Limit each IP to 20 create requests per hour
  message: 'Too many creation requests, please try again later.',
});

// Basic middleware
app.use(cors(corsOptions));
app.use(express.json());
app.use(generalLimiter); // Apply general rate limiting to all routes

// Simple file-based storage for demo
const dataFile = path.join(__dirname, 'data.json');

// Initialize data file if it doesn't exist
const initializeData = async () => {
  const defaultData = {
    users: [
      {
        id: 'user-001',
        username: 'demo-user',
        password: 'password123', // In real app, this would be hashed
        email: 'demo@qaest.com',
        firstName: 'Demo',
        lastName: 'User',
        role: 'senior_qa',
        status: 'active',
        approvalStatus: 'approved',
        approvedBy: 'system',
        approvedAt: new Date().toISOString(),
        createdAt: new Date().toISOString()
      },
      {
        id: 'user-002',
        username: 'qa-lead',
        password: 'lead123',
        email: 'lead@qaest.com',
        firstName: 'QA',
        lastName: 'Lead',
        role: 'qa_lead',
        status: 'active',
        approvalStatus: 'approved',
        approvedBy: 'system',
        approvedAt: new Date().toISOString(),
        createdAt: new Date().toISOString()
      },
      {
        id: 'user-003',
        username: 'junior-qa',
        password: 'junior123',
        email: 'junior@qaest.com',
        firstName: 'Junior',
        lastName: 'QA',
        role: 'junior_qa',
        status: 'active',
        approvalStatus: 'approved',
        approvedBy: 'system',
        approvedAt: new Date().toISOString(),
        createdAt: new Date().toISOString()
      },
      {
        id: 'user-004',
        username: 'project-manager',
        password: 'pm123',
        email: 'pm@qaest.com',
        firstName: 'Project',
        lastName: 'Manager',
        role: 'project_manager',
        status: 'active',
        approvalStatus: 'approved',
        approvedBy: 'system',
        approvedAt: new Date().toISOString(),
        createdAt: new Date().toISOString()
      }
    ],
      testCases: [
        {
          id: 'TC-000001',
          title: 'User Login Functionality Test',
          description: 'Test user login with valid credentials',
          priority: 'high',
          status: 'active',
          category: 'Authentication',
          module: 'User Management',
          appType: 'web',
          osType: 'cross_platform',
          createdBy: 'demo-user',
          createdAt: new Date().toISOString()
        },
        {
          id: 'TC-000002',
          title: 'Test Case Creation Test',
          description: 'Verify test case creation functionality',
          priority: 'medium',
          status: 'draft',
          category: 'Test Management',
          module: 'Test Cases',
          appType: 'web',
          osType: 'cross_platform',
          createdBy: 'qa-lead',
          createdAt: new Date().toISOString()
        }
      ],
    approvalRequests: []
  };

  if (!fs.existsSync(dataFile)) {
    await fs.promises.writeFile(dataFile, JSON.stringify(defaultData, null, 2));
  }
};

// Read data from file
const readData = async () => {
  try {
    const data = await fs.promises.readFile(dataFile, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    console.error('Error reading data file:', error);
    await initializeData();
    return await readData();
  }
};

// Write data to file
const writeData = async (data) => {
  let release;
  try {
    // Acquire lock with retry options
    release = await lockfile.lock(dataFile, {
      retries: {
        retries: 5,
        factor: 3,
        minTimeout: 100,
        maxTimeout: 1000,
        randomize: true
      }
    });
    
    // Write data
    await fs.promises.writeFile(dataFile, JSON.stringify(data, null, 2));
    
    // Release lock
    await release();
    return true;
  } catch (error) {
    console.error('Error writing data file:', error);
    if (release) {
      try {
        await release();
      } catch (releaseError) {
        console.error('Error releasing lock:', releaseError);
      }
    }
    return false;
  }
};

// Utility function to generate user ID
const generateUserId = (data) => {
  const existingIds = data.users.map(u => parseInt(u.id.replace('user-', ''))).sort((a, b) => b - a);
  const nextId = existingIds.length > 0 ? existingIds[0] + 1 : 5;
  return 'user-' + String(nextId).padStart(3, '0');
};

// Utility function to generate approval request ID
const generateApprovalRequestId = (data) => {
  const existingIds = data.approvalRequests.map(r => parseInt(r.id.replace('req-', ''))).sort((a, b) => b - a);
  const nextId = existingIds.length > 0 ? existingIds[0] + 1 : 1;
  return 'req-' + String(nextId).padStart(3, '0');
};

// Utility function to generate notification ID
const generateNotificationId = (data) => {
  const existingIds = (data.notifications || [])
    .map(n => parseInt(n.id.replace('notif-', '')))
    .filter(id => !isNaN(id))
    .sort((a, b) => b - a);
  const nextId = existingIds.length > 0 ? existingIds[0] + 1 : 1;
  return 'notif-' + String(nextId).padStart(6, '0');
};

// Check if user has approval permissions
const hasApprovalPermissions = (user) => {
  return user && (user.role === 'qa_lead' || user.role === 'project_manager');
};

// Authorization middleware - checks if user has required role
const requireRole = (roles) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'Authentication required'
      });
    }

    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: 'Insufficient permissions. Required role: ' + roles.join(' or ')
      });
    }

    next();
  };
};

// Authentication middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({
      success: false,
      message: 'Access token required'
    });
  }

  // Verify JWT token
  jwt.verify(token, JWT_SECRET, (err, decoded) => {
    if (err) {
      return res.status(403).json({
        success: false,
        message: 'Invalid or expired token'
      });
    }

    // Get fresh user data from database
    const data = readData();
    const user = data.users.find(u => u.id === decoded.userId);
    
    if (!user || user.status !== 'active') {
      return res.status(403).json({
        success: false,
        message: 'User not found or inactive'
      });
    }

    // Attach user to request
    req.user = user;
    req.decoded = decoded;
    next();
  });
};

// Get user from token
const getUserFromToken = (token, data) => {
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    return data.users.find(u => u.id === decoded.userId && u.status === 'active');
  } catch (err) {
    return null;
  }
};

// Initialize data on startup
initializeData();

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

// Root endpoint
app.get('/', (req, res) => {
  res.json({
    message: 'Welcome to QAest API - Basic Version',
    version: '1.0.0',
    status: 'Server is running successfully!',
    endpoints: [
      'GET /health - Health check',
      'POST /api/auth/login - User login',
      'POST /api/auth/register - User registration',
      'GET /api/users/pending - Get pending user approvals',
      'PUT /api/users/:id/approve - Approve user',
      'PUT /api/users/:id/reject - Reject user',
      'PUT /api/users/:id/role - Update user role',
      'GET /api/users - Get all users (admin)',
      'GET /api/demo - Demo data',
      'GET /api/test-cases - Get all test cases (with filters)',
      'POST /api/test-cases - Create test case'
    ]
  });
});

// User registration endpoint
app.post('/api/auth/register', authLimiter, async (req, res) => {
  const { username, password, email, firstName, lastName, role } = req.body;
  
  // Validation
  if (!username || !password || !email || !firstName || !lastName) {
    return res.status(400).json({
      success: false,
      message: 'All fields are required: username, password, email, firstName, lastName'
    });
  }

  // Validate role
  const validRoles = ['qa_lead', 'senior_qa', 'junior_qa', 'project_manager', 'stakeholder'];
  const userRole = role && validRoles.includes(role) ? role : 'junior_qa';

  const data = readData();
  
  // Check if username already exists
  const existingUser = data.users.find(u => u.username === username);
  if (existingUser) {
    return res.status(409).json({
      success: false,
      message: 'Username already exists'
    });
  }

  // Check if email already exists
  const existingEmail = data.users.find(u => u.email === email);
  if (existingEmail) {
    return res.status(409).json({
      success: false,
      message: 'Email already exists'
    });
  }

  // Hash the password
  const hashedPassword = bcrypt.hashSync(password, 10);
  
  // Create new user with pending approval
  const newUser = {
    id: generateUserId(data),
    username,
    password: hashedPassword,
    email,
    firstName,
    lastName,
    role: userRole,
    status: 'pending_approval',
    approvalStatus: 'pending',
    approvedBy: null,
    approvedAt: null,
    createdAt: new Date().toISOString()
  };

  // Create approval request
  const approvalRequest = {
    id: generateApprovalRequestId(data),
    userId: newUser.id,
    requestType: 'registration',
    requestedRole: userRole,
    currentRole: null,
    requestedBy: newUser.id,
    status: 'pending',
    createdAt: new Date().toISOString(),
    approvedBy: null,
    approvedAt: null,
    rejectedBy: null,
    rejectedAt: null,
    rejectionReason: null
  };

  data.users.push(newUser);
  data.approvalRequests.push(approvalRequest);

  // Create notifications for all QA Leads and Project Managers
  if (!data.notifications) {
    data.notifications = [];
  }
  
  const approvers = data.users.filter(u => 
    (u.role === 'qa_lead' || u.role === 'project_manager') && 
    u.status === 'active' && 
    u.approvalStatus === 'approved'
  );
  
  approvers.forEach(approver => {
    data.notifications.push({
      id: generateNotificationId(data),
      type: 'approval_pending',
      title: 'New User Registration',
      message: `${newUser.firstName} ${newUser.lastName} has registered as ${userRole.replace('_', ' ')} and is awaiting approval.`,
      userId: approver.id,
      relatedEntityType: 'approval_request',
      relatedEntityId: approvalRequest.id,
      isRead: false,
      createdAt: new Date().toISOString(),
      actionUrl: '/approvals',
      actionLabel: 'Review'
    });
  });

  if (await writeData(data)) {
    res.status(201).json({
      success: true,
      message: 'Registration successful. Your account is pending approval by a Lead or Project Manager.',
      data: {
        user: {
          id: newUser.id,
          username: newUser.username,
          email: newUser.email,
          firstName: newUser.firstName,
          lastName: newUser.lastName,
          role: newUser.role,
          status: newUser.status,
          approvalStatus: newUser.approvalStatus
        },
        requiresApproval: true
      }
    });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to register user'
    });
  }
});

// Login endpoint
app.post('/api/auth/login', authLimiter, (req, res) => {
  const { username, password } = req.body;
  
  if (!username || !password) {
    return res.status(400).json({
      success: false,
      message: 'Username and password are required'
    });
  }
  
  const data = readData();
  const user = data.users.find(u => u.username === username);
  
  if (!user) {
    return res.status(401).json({
      success: false,
      message: 'Invalid username or password'
    });
  }
  
  // Verify password
  const isPasswordValid = bcrypt.compareSync(password, user.password);
  if (!isPasswordValid) {
    return res.status(401).json({
      success: false,
      message: 'Invalid username or password'
    });
  }

  // Check if user is approved
  if (user.approvalStatus !== 'approved') {
    return res.status(403).json({
      success: false,
      message: 'Your account is pending approval. Please contact a Lead or Project Manager.',
      data: {
        approvalStatus: user.approvalStatus,
        requiresApproval: true
      }
    });
  }

  // Check if user is active
  if (user.status !== 'active') {
    return res.status(403).json({
      success: false,
      message: 'Your account has been deactivated. Please contact an administrator.'
    });
  }

  // Generate JWT token
  const token = jwt.sign(
    { 
      userId: user.id, 
      username: user.username,
      role: user.role,
      email: user.email
    },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRY }
  );
  
  // Remove password from response
  const { password: _, ...userWithoutPassword } = user;
  
  res.json({
    success: true,
    message: 'Login successful',
    data: {
      user: userWithoutPassword,
      token: token
    }
  });
});

// Get pending user approvals (for Leads and Project Managers)
app.get('/api/users/pending', authenticateToken, requireRole(['qa_lead', 'project_manager']), (req, res) => {
  const data = readData();
  
  // Get current user from middleware
  const currentUser = req.user;

  if (!hasApprovalPermissions(currentUser)) {
    return res.status(403).json({
      success: false,
      message: 'Access denied. Only Leads and Project Managers can view pending approvals.'
    });
  }

  // Get pending users and approval requests
  const pendingUsers = data.users.filter(u => u.approvalStatus === 'pending');
  const pendingRequests = data.approvalRequests.filter(r => r.status === 'pending');

  // Combine user data with request data
  const pendingApprovals = pendingUsers.map(user => {
    const request = pendingRequests.find(r => r.userId === user.id);
    return {
      ...user,
      requestId: request?.id,
      requestType: request?.requestType,
      requestedRole: request?.requestedRole
    };
  });

  res.json({
    success: true,
    data: {
      pendingApprovals,
      totalCount: pendingApprovals.length
    }
  });
});

// Get all users (for admin management)
app.get('/api/users', authenticateToken, (req, res) => {
  const data = readData();
  
  // Get current user from middleware
  const currentUser = req.user;

  if (!hasApprovalPermissions(currentUser)) {
    return res.status(403).json({
      success: false,
      message: 'Access denied. Only Leads and Project Managers can view all users.'
    });
  }

  // Remove passwords from response
  const users = data.users.map(({ password, ...user }) => user);

  res.json({
    success: true,
    data: {
      users,
      totalCount: users.length
    }
  });
});

// Approve user
app.put('/api/users/:id/approve', authenticateToken, requireRole(['qa_lead', 'project_manager']), async (req, res) => {
  const { id } = req.params;
  const data = readData();
  
  // Get current user from middleware
  const currentUser = req.user;

  if (!hasApprovalPermissions(currentUser)) {
    return res.status(403).json({
      success: false,
      message: 'Access denied. Only Leads and Project Managers can approve users.'
    });
  }

  const user = data.users.find(u => u.id === id);
  if (!user) {
    return res.status(404).json({
      success: false,
      message: 'User not found'
    });
  }

  if (user.approvalStatus === 'approved') {
    return res.status(400).json({
      success: false,
      message: 'User is already approved'
    });
  }

  // Update user status
  user.approvalStatus = 'approved';
  user.status = 'active';
  user.approvedBy = currentUser.id;
  user.approvedAt = new Date().toISOString();

  // Update approval request
  const request = data.approvalRequests.find(r => r.userId === id && r.status === 'pending');
  if (request) {
    request.status = 'approved';
    request.approvedBy = currentUser.id;
    request.approvedAt = new Date().toISOString();
  }

  // Create notification for the approved user
  if (!data.notifications) {
    data.notifications = [];
  }
  
  data.notifications.push({
    id: generateNotificationId(data),
    type: 'success',
    title: 'Account Approved!',
    message: `Your account has been approved by ${currentUser.firstName} ${currentUser.lastName}. You can now log in.`,
    userId: user.id,
    relatedEntityType: 'user',
    relatedEntityId: user.id,
    isRead: false,
    createdAt: new Date().toISOString(),
    actionUrl: '/login',
    actionLabel: 'Log In'
  });

  if (await writeData(data)) {
    res.json({
      success: true,
      message: `User ${user.firstName} ${user.lastName} has been approved`,
      data: {
        user: { ...user, password: undefined }
      }
    });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to approve user'
    });
  }
});

// Reject user
app.put('/api/users/:id/reject', authenticateToken, requireRole(['qa_lead', 'project_manager']), async (req, res) => {
  const { id } = req.params;
  const { reason } = req.body;
  const data = readData();
  
  // Get current user from middleware
  const currentUser = req.user;

  if (!hasApprovalPermissions(currentUser)) {
    return res.status(403).json({
      success: false,
      message: 'Access denied. Only Leads and Project Managers can reject users.'
    });
  }

  const user = data.users.find(u => u.id === id);
  if (!user) {
    return res.status(404).json({
      success: false,
      message: 'User not found'
    });
  }

  if (user.approvalStatus === 'approved') {
    return res.status(400).json({
      success: false,
      message: 'Cannot reject an already approved user'
    });
  }

  // Update user status
  user.approvalStatus = 'rejected';
  user.status = 'rejected';

  // Update approval request
  const request = data.approvalRequests.find(r => r.userId === id && r.status === 'pending');
  if (request) {
    request.status = 'rejected';
    request.rejectedBy = currentUser.id;
    request.rejectedAt = new Date().toISOString();
    request.rejectionReason = reason || 'No reason provided';
  }

  // Create notification for the rejected user
  if (!data.notifications) {
    data.notifications = [];
  }
  
  data.notifications.push({
    id: generateNotificationId(data),
    type: 'error',
    title: 'Account Rejected',
    message: `Your account request has been rejected by ${currentUser.firstName} ${currentUser.lastName}. Reason: ${reason || 'No reason provided'}`,
    userId: user.id,
    relatedEntityType: 'user',
    relatedEntityId: user.id,
    isRead: false,
    createdAt: new Date().toISOString()
  });

  if (await writeData(data)) {
    res.json({
      success: true,
      message: `User ${user.firstName} ${user.lastName} has been rejected`,
      data: {
        user: { ...user, password: undefined }
      }
    });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to reject user'
    });
  }
});

// Update user role
app.put('/api/users/:id/role', authenticateToken, async (req, res) => {
  const { id } = req.params;
  const { newRole, reason } = req.body;
  const data = readData();
  
  // Get current user from middleware
  const currentUser = req.user;

  if (!hasApprovalPermissions(currentUser)) {
    return res.status(403).json({
      success: false,
      message: 'Access denied. Only Leads and Project Managers can update user roles.'
    });
  }

  const validRoles = ['qa_lead', 'senior_qa', 'junior_qa', 'project_manager', 'stakeholder'];
  if (!validRoles.includes(newRole)) {
    return res.status(400).json({
      success: false,
      message: 'Invalid role specified'
    });
  }

  const user = data.users.find(u => u.id === id);
  if (!user) {
    return res.status(404).json({
      success: false,
      message: 'User not found'
    });
  }

  if (user.approvalStatus !== 'approved') {
    return res.status(400).json({
      success: false,
      message: 'Cannot update role for unapproved users'
    });
  }

  if (user.role === newRole) {
    return res.status(400).json({
      success: false,
      message: 'User already has this role'
    });
  }

  const oldRole = user.role;
  user.role = newRole;

  // Create approval request for role change
  const approvalRequest = {
    id: generateApprovalRequestId(data),
    userId: user.id,
    requestType: 'role_change',
    requestedRole: newRole,
    currentRole: oldRole,
    requestedBy: currentUser.id,
    status: 'approved', // Auto-approved since it's done by admin
    createdAt: new Date().toISOString(),
    approvedBy: currentUser.id,
    approvedAt: new Date().toISOString(),
    rejectedBy: null,
    rejectedAt: null,
    rejectionReason: null,
    changeReason: reason || 'Role updated by administrator'
  };

  data.approvalRequests.push(approvalRequest);

  // Create notification for the user whose role was changed
  if (!data.notifications) {
    data.notifications = [];
  }
  
  data.notifications.push({
    id: generateNotificationId(data),
    type: 'info',
    title: 'Role Updated',
    message: `Your role has been updated from ${oldRole.replace('_', ' ')} to ${newRole.replace('_', ' ')} by ${currentUser.firstName} ${currentUser.lastName}. ${reason ? `Reason: ${reason}` : ''}`,
    userId: user.id,
    relatedEntityType: 'role_change',
    relatedEntityId: approvalRequest.id,
    isRead: false,
    createdAt: new Date().toISOString()
  });

  if (await writeData(data)) {
    res.json({
      success: true,
      message: `User ${user.firstName} ${user.lastName} role updated from ${oldRole} to ${newRole}`,
      data: {
        user: { ...user, password: undefined },
        oldRole,
        newRole
      }
    });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to update user role'
    });
  }
});

// Get all test cases with filtering
app.get('/api/test-cases', (req, res) => {
  const data = readData();
  let testCases = [...data.testCases];

  // Apply filters
  const { 
    priority, 
    createdBy, 
    dateFrom, 
    dateTo, 
    status, 
    category,
    search 
  } = req.query;

  // Filter by priority
  if (priority) {
    testCases = testCases.filter(tc => tc.priority === priority);
  }

  // Filter by creator
  if (createdBy) {
    testCases = testCases.filter(tc => tc.createdBy === createdBy);
  }

  // Filter by status
  if (status) {
    testCases = testCases.filter(tc => tc.status === status);
  }

  // Filter by category
  if (category) {
    testCases = testCases.filter(tc => tc.category.toLowerCase().includes(category.toLowerCase()));
  }

  // Filter by date range
  if (dateFrom) {
    const fromDate = new Date(dateFrom);
    testCases = testCases.filter(tc => new Date(tc.createdAt) >= fromDate);
  }

  if (dateTo) {
    const toDate = new Date(dateTo);
    toDate.setHours(23, 59, 59, 999); // End of day
    testCases = testCases.filter(tc => new Date(tc.createdAt) <= toDate);
  }

  // Search in title and description
  if (search) {
    const searchTerm = search.toLowerCase();
    testCases = testCases.filter(tc => 
      tc.title.toLowerCase().includes(searchTerm) ||
      tc.description.toLowerCase().includes(searchTerm)
    );
  }

  // Sort by creation date (newest first)
  testCases.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

  // Pagination
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 10;
  const startIndex = (page - 1) * limit;
  const endIndex = page * limit;
  
  const totalCount = testCases.length;
  const totalPages = Math.ceil(totalCount / limit);
  const paginatedTestCases = testCases.slice(startIndex, endIndex);

  res.json({
    success: true,
    message: 'Test cases retrieved successfully',
    data: {
      testCases: paginatedTestCases,
      pagination: {
        currentPage: page,
        totalPages,
        totalCount,
        limit,
        hasNextPage: endIndex < totalCount,
        hasPrevPage: startIndex > 0
      },
      filters: {
        priority: priority || null,
        createdBy: createdBy || null,
        dateFrom: dateFrom || null,
        dateTo: dateTo || null,
        status: status || null,
        category: category || null,
        search: search || null
      }
    }
  });
});

// Get unique filter values for dropdowns
app.get('/api/test-cases/filters', (req, res) => {
  const data = readData();
  
  const priorities = [...new Set(data.testCases.map(tc => tc.priority))];
  const creators = [...new Set(data.testCases.map(tc => tc.createdBy))];
  const statuses = [...new Set(data.testCases.map(tc => tc.status))];
  const categories = [...new Set(data.testCases.map(tc => tc.category))];

  res.json({
    success: true,
    data: {
      priorities: priorities.sort(),
      creators: creators.sort(),
      statuses: statuses.sort(),
      categories: categories.sort()
    }
  });
});

// Create test case
app.post('/api/test-cases', createLimiter, async (req, res) => {
  const data = readData();
  
  // Generate new test case ID
  const existingIds = data.testCases.map(tc => parseInt(tc.id.replace('TC-', ''))).sort((a, b) => b - a);
  const nextId = existingIds.length > 0 ? existingIds[0] + 1 : 1;
  const testCaseId = 'TC-' + String(nextId).padStart(6, '0');
  
  const newTestCase = {
    id: testCaseId,
    title: req.body.title || 'Untitled Test Case',
    description: req.body.description || '',
    priority: req.body.priority || 'medium',
    status: req.body.status || 'draft',
    category: req.body.category || 'General',
    module: req.body.module || 'Unknown',
    appType: req.body.appType || 'web',
    osType: req.body.osType || 'cross_platform',
    createdBy: req.body.createdBy || 'unknown',
    createdAt: new Date().toISOString()
  };
  
  data.testCases.push(newTestCase);
  
  if (await writeData(data)) {
    res.json({
      success: true,
      message: 'Test case created successfully',
      data: { testCase: newTestCase }
    });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to save test case'
    });
  }
});

// Demo API endpoint (for backward compatibility)
app.get('/api/demo', (req, res) => {
  const data = readData();
  res.json({
    success: true,
    message: 'QAest API is working!',
    data: {
      testCases: data.testCases,
      totalCount: data.testCases.length,
      currentUser: {
        id: 'user-001',
        username: 'demo-user',
        role: 'senior_qa',
        permissions: ['read', 'create', 'update']
      }
    }
  });
});

// Demo test case creation (for backward compatibility)
app.post('/api/test-cases/demo', async (req, res) => {
  const data = readData();
  
  const existingIds = data.testCases.map(tc => parseInt(tc.id.replace('TC-', ''))).sort((a, b) => b - a);
  const nextId = existingIds.length > 0 ? existingIds[0] + 1 : 1;
  const testCaseId = 'TC-' + String(nextId).padStart(6, '0');
  
  const testCase = {
    id: testCaseId,
    ...req.body,
    module: req.body.module || 'Test Cases',
    appType: req.body.appType || 'web',
    osType: req.body.osType || 'cross_platform',
    createdBy: 'demo-user',
    createdAt: new Date().toISOString(),
    status: req.body.status || 'draft'
  };
  
  data.testCases.push(testCase);
  
  if (await writeData(data)) {
  res.json({
    success: true,
    message: 'Demo test case created successfully',
    data: { testCase }
  });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to save test case'
    });
  }
});

// Update test case
app.put('/api/test-cases/:id', authenticateToken, async (req, res) => {
  const { id } = req.params;
  const updateData = req.body;
  const data = readData();
  
  // Find test case
  const testCaseIndex = data.testCases.findIndex(tc => tc.id === id);
  if (testCaseIndex === -1) {
    return res.status(404).json({
      success: false,
      message: 'Test case not found'
    });
  }
  
  const testCase = data.testCases[testCaseIndex];
  
  // Check ownership or permission
  if (testCase.createdBy !== req.user.id) {
    // Check if user has edit permission
    const hasPermission = (data.permissionRequests || []).some(pr => 
      pr.testCaseId === id && 
      pr.requesterId === req.user.id && 
      pr.permissionType === 'edit' && 
      pr.status === 'approved'
    );
    
    if (!hasPermission) {
      return res.status(403).json({
        success: false,
        message: 'You do not have permission to edit this test case'
      });
    }
  }
  
  // Update test case
  data.testCases[testCaseIndex] = {
    ...testCase,
    ...updateData,
    id: testCase.id, // Preserve ID
    createdBy: testCase.createdBy, // Preserve creator
    createdAt: testCase.createdAt, // Preserve creation date
    updatedAt: new Date().toISOString(),
    updatedBy: req.user.id
  };
  
  if (await writeData(data)) {
    res.json({
      success: true,
      message: 'Test case updated successfully',
      data: { testCase: data.testCases[testCaseIndex] }
    });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to update test case'
    });
  }
});

// Delete test case
app.delete('/api/test-cases/:id', authenticateToken, async (req, res) => {
  const { id } = req.params;
  const data = readData();
  
  // Find test case
  const testCaseIndex = data.testCases.findIndex(tc => tc.id === id);
  if (testCaseIndex === -1) {
    return res.status(404).json({
      success: false,
      message: 'Test case not found'
    });
  }
  
  const testCase = data.testCases[testCaseIndex];
  
  // Check ownership or permission
  if (testCase.createdBy !== req.user.id) {
    // Check if user has delete permission
    const hasPermission = (data.permissionRequests || []).some(pr => 
      pr.testCaseId === id && 
      pr.requesterId === req.user.id && 
      pr.permissionType === 'delete' && 
      pr.status === 'approved'
    );
    
    if (!hasPermission && req.user.role !== 'qa_lead' && req.user.role !== 'project_manager') {
      return res.status(403).json({
        success: false,
        message: 'You do not have permission to delete this test case'
      });
    }
  }
  
  // Remove test case
  data.testCases.splice(testCaseIndex, 1);
  
  // Also remove associated permission requests
  if (data.permissionRequests) {
    data.permissionRequests = data.permissionRequests.filter(pr => pr.testCaseId !== id);
  }
  
  if (await writeData(data)) {
    res.json({
      success: true,
      message: 'Test case deleted successfully'
    });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to delete test case'
    });
  }
});

// Permission Management Endpoints

// Get my permission requests
app.get('/api/permissions/my-requests', authenticateToken, (req, res) => {
  const data = readData();
  const userId = req.user.id;
  
  const myRequests = (data.permissionRequests || [])
    .filter(request => request.requesterId === userId)
    .map(request => {
      const testCase = data.testCases.find(tc => tc.id === request.testCaseId);
      const owner = data.users.find(u => u.id === request.ownerId);
      return {
        ...request,
        testCaseTitle: testCase ? testCase.title : 'Unknown Test Case',
        ownerName: owner ? `${owner.firstName} ${owner.lastName}` : 'Unknown User',
        requesterName: req.user.firstName + ' ' + req.user.lastName
      };
    })
    .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  
  res.json({
    success: true,
    data: myRequests
  });
});

// Get pending approvals (requests where I'm the owner)
app.get('/api/permissions/pending-approvals', authenticateToken, (req, res) => {
  const data = readData();
  const userId = req.user.id;
  
  const pendingApprovals = (data.permissionRequests || [])
    .filter(request => request.ownerId === userId)
    .map(request => {
      const testCase = data.testCases.find(tc => tc.id === request.testCaseId);
      const requester = data.users.find(u => u.id === request.requesterId);
      return {
        ...request,
        testCaseTitle: testCase ? testCase.title : 'Unknown Test Case',
        requesterName: requester ? `${requester.firstName} ${requester.lastName}` : 'Unknown User',
        ownerName: req.user.firstName + ' ' + req.user.lastName
      };
    })
    .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  
  res.json({
    success: true,
    data: pendingApprovals
  });
});

// Request permission
app.post('/api/permissions/request', authenticateToken, async (req, res) => {
  const { testCaseId, permissionType, reason } = req.body;
  
  if (!testCaseId || !permissionType || !reason) {
    return res.status(400).json({
      success: false,
      message: 'Test case ID, permission type, and reason are required'
    });
  }
  
  const data = readData();
  const testCase = data.testCases.find(tc => tc.id === testCaseId);
  
  if (!testCase) {
    return res.status(404).json({
      success: false,
      message: 'Test case not found'
    });
  }
  
  // Check if user is already the owner
  if (testCase.createdBy === req.user.username) {
    return res.status(400).json({
      success: false,
      message: 'You already own this test case'
    });
  }
  
  // Check for existing pending request
  const existingRequest = (data.permissionRequests || []).find(
    r => r.testCaseId === testCaseId && 
         r.requesterId === req.user.id && 
         r.status === 'pending'
  );
  
  if (existingRequest) {
    return res.status(400).json({
      success: false,
      message: 'You already have a pending request for this test case'
    });
  }
  
  // Find owner
  const owner = data.users.find(u => u.username === testCase.createdBy);
  if (!owner) {
    return res.status(404).json({
      success: false,
      message: 'Test case owner not found'
    });
  }
  
  // Create permission request
  const newRequest = {
    id: 'PR-' + Date.now(),
    testCaseId,
    requesterId: req.user.id,
    ownerId: owner.id,
    permissionType,
    status: 'pending',
    reason,
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // 7 days
    createdAt: new Date().toISOString(),
    resolvedAt: null,
    resolvedBy: null,
    resolutionNote: null
  };
  
  if (!data.permissionRequests) {
    data.permissionRequests = [];
  }
  data.permissionRequests.push(newRequest);
  
  // Add notification for owner
  if (!data.notifications) {
    data.notifications = [];
  }
  data.notifications.push({
    id: 'N-' + Date.now(),
    userId: owner.id,
    type: 'permission_request',
    title: 'New Permission Request',
    message: `${req.user.firstName} ${req.user.lastName} has requested ${permissionType} permission for "${testCase.title}"`,
    relatedEntityType: 'permission_request',
    relatedEntityId: newRequest.id,
    isRead: false,
    createdAt: new Date().toISOString(),
    actionUrl: '/permissions',
    actionLabel: 'View Request'
  });
  
  if (await writeData(data)) {
    res.json({
      success: true,
      message: 'Permission request submitted successfully',
      data: newRequest
    });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to submit permission request'
    });
  }
});

// Approve permission request
app.put('/api/permissions/:requestId/approve', authenticateToken, async (req, res) => {
  const { requestId } = req.params;
  const { resolutionNote } = req.body;
  
  const data = readData();
  const request = (data.permissionRequests || []).find(r => r.id === requestId);
  
  if (!request) {
    return res.status(404).json({
      success: false,
      message: 'Permission request not found'
    });
  }
  
  // Check if user is the owner
  if (request.ownerId !== req.user.id) {
    return res.status(403).json({
      success: false,
      message: 'You are not authorized to approve this request'
    });
  }
  
  // Check if request is pending
  if (request.status !== 'pending') {
    return res.status(400).json({
      success: false,
      message: 'This request has already been resolved'
    });
  }
  
  // Update request
  request.status = 'approved';
  request.resolvedAt = new Date().toISOString();
  request.resolvedBy = req.user.id;
  request.resolutionNote = resolutionNote || null;
  
  // Add notification for requester
  const requester = data.users.find(u => u.id === request.requesterId);
  if (!data.notifications) {
    data.notifications = [];
  }
  data.notifications.push({
    id: 'N-' + Date.now(),
    userId: request.requesterId,
    type: 'success',
    title: 'Permission Request Approved',
    message: `Your ${request.permissionType} request has been approved by ${req.user.firstName} ${req.user.lastName}`,
    relatedEntityType: 'permission_request',
    relatedEntityId: request.id,
    isRead: false,
    createdAt: new Date().toISOString()
  });
  
  // Add audit log entry
  if (!data.auditLog) {
    data.auditLog = [];
  }
  data.auditLog.push({
    id: 'AL-' + Date.now(),
    action: 'permission_granted',
    entityType: 'permission_request',
    entityId: request.id,
    performedBy: req.user.id,
    performedByName: `${req.user.firstName} ${req.user.lastName}`,
    targetUser: request.requesterId,
    targetUserName: requester ? `${requester.firstName} ${requester.lastName}` : 'Unknown User',
    details: {
      permissionType: request.permissionType,
      testCaseId: request.testCaseId,
      resolutionNote
    },
    createdAt: new Date().toISOString()
  });
  
  if (await writeData(data)) {
    res.json({
      success: true,
      message: 'Permission request approved successfully'
    });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to approve permission request'
    });
  }
});

// Deny permission request
app.put('/api/permissions/:requestId/deny', authenticateToken, async (req, res) => {
  const { requestId } = req.params;
  const { resolutionNote } = req.body;
  
  const data = readData();
  const request = (data.permissionRequests || []).find(r => r.id === requestId);
  
  if (!request) {
    return res.status(404).json({
      success: false,
      message: 'Permission request not found'
    });
  }
  
  // Check if user is the owner
  if (request.ownerId !== req.user.id) {
    return res.status(403).json({
      success: false,
      message: 'You are not authorized to deny this request'
    });
  }
  
  // Check if request is pending
  if (request.status !== 'pending') {
    return res.status(400).json({
      success: false,
      message: 'This request has already been resolved'
    });
  }
  
  // Update request
  request.status = 'denied';
  request.resolvedAt = new Date().toISOString();
  request.resolvedBy = req.user.id;
  request.resolutionNote = resolutionNote || null;
  
  // Add notification for requester
  const requester = data.users.find(u => u.id === request.requesterId);
  if (!data.notifications) {
    data.notifications = [];
  }
  data.notifications.push({
    id: 'N-' + Date.now(),
    userId: request.requesterId,
    type: 'error',
    title: 'Permission Request Denied',
    message: `Your ${request.permissionType} request has been denied by ${req.user.firstName} ${req.user.lastName}${resolutionNote ? ': ' + resolutionNote : ''}`,
    relatedEntityType: 'permission_request',
    relatedEntityId: request.id,
    isRead: false,
    createdAt: new Date().toISOString()
  });
  
  // Add audit log entry
  if (!data.auditLog) {
    data.auditLog = [];
  }
  data.auditLog.push({
    id: 'AL-' + Date.now(),
    action: 'permission_denied',
    entityType: 'permission_request',
    entityId: request.id,
    performedBy: req.user.id,
    performedByName: `${req.user.firstName} ${req.user.lastName}`,
    targetUser: request.requesterId,
    targetUserName: requester ? `${requester.firstName} ${requester.lastName}` : 'Unknown User',
    details: {
      permissionType: request.permissionType,
      testCaseId: request.testCaseId,
      resolutionNote
    },
    createdAt: new Date().toISOString()
  });
  
  if (await writeData(data)) {
    res.json({
      success: true,
      message: 'Permission request denied'
    });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to deny permission request'
    });
  }
});

// Get notifications
app.get('/api/notifications', authenticateToken, (req, res) => {
  const data = readData();
  const userId = req.user.id;
  
  const notifications = (data.notifications || [])
    .filter(n => n.userId === userId)
    .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
    .slice(0, 50); // Return latest 50 notifications
  
  res.json({
    success: true,
    data: notifications
  });
});

// Mark notification as read
app.put('/api/notifications/:notificationId/read', authenticateToken, async (req, res) => {
  const { notificationId } = req.params;
  const data = readData();
  
  const notification = (data.notifications || []).find(
    n => n.id === notificationId && n.userId === req.user.id
  );
  
  if (!notification) {
    return res.status(404).json({
      success: false,
      message: 'Notification not found'
    });
  }
  
  notification.isRead = true;
  
  if (await writeData(data)) {
    res.json({
      success: true,
      message: 'Notification marked as read'
    });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to update notification'
    });
  }
});

// Mark all notifications as read
app.put('/api/notifications/mark-all-read', authenticateToken, async (req, res) => {
  const data = readData();
  const userId = req.user.id;
  
  if (data.notifications) {
    data.notifications.forEach(n => {
      if (n.userId === userId) {
        n.isRead = true;
      }
    });
  }
  
  if (await writeData(data)) {
    res.json({
      success: true,
      message: 'All notifications marked as read'
    });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to update notifications'
    });
  }
});

// Delete notification
app.delete('/api/notifications/:notificationId', authenticateToken, async (req, res) => {
  const { notificationId } = req.params;
  const data = readData();
  
  if (!data.notifications) {
    return res.status(404).json({
      success: false,
      message: 'Notification not found'
    });
  }
  
  const notificationIndex = data.notifications.findIndex(
    n => n.id === notificationId && n.userId === req.user.id
  );
  
  if (notificationIndex === -1) {
    return res.status(404).json({
      success: false,
      message: 'Notification not found'
    });
  }
  
  data.notifications.splice(notificationIndex, 1);
  
  if (await writeData(data)) {
    res.json({
      success: true,
      message: 'Notification deleted'
    });
  } else {
    res.status(500).json({
      success: false,
      message: 'Failed to delete notification'
    });
  }
});

// Get audit log
app.get('/api/audit-log', authenticateToken, (req, res) => {
  const { action, entityType, performedBy, dateFrom, dateTo, entityId } = req.query;
  const data = readData();
  
  let auditEntries = data.auditLog || [];
  
  // Apply filters
  if (action) {
    auditEntries = auditEntries.filter(entry => entry.action === action);
  }
  if (entityType) {
    auditEntries = auditEntries.filter(entry => entry.entityType === entityType);
  }
  if (performedBy) {
    auditEntries = auditEntries.filter(entry => entry.performedBy === performedBy);
  }
  if (entityId) {
    auditEntries = auditEntries.filter(entry => entry.entityId === entityId);
  }
  if (dateFrom) {
    auditEntries = auditEntries.filter(entry => new Date(entry.createdAt) >= new Date(dateFrom));
  }
  if (dateTo) {
    auditEntries = auditEntries.filter(entry => new Date(entry.createdAt) <= new Date(dateTo));
  }
  
  // Sort by date descending
  auditEntries.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  
  res.json({
    success: true,
    data: auditEntries.slice(0, 100) // Return latest 100 entries
  });
});

const PORT = process.env.PORT || 8000;

app.listen(PORT, () => {
  console.log('ğŸš€ QAest Basic Server Started!');
  console.log('================================');
  console.log(`ğŸ“ Server running on: http://localhost:${PORT}`);
  console.log(`ğŸ” Health check: http://localhost:${PORT}/health`);
  console.log(`ğŸ  Home page: http://localhost:${PORT}/`);
  console.log(`ğŸ“Š Demo API: http://localhost:${PORT}/api/demo`);
  console.log(`ğŸ” Login: POST http://localhost:${PORT}/api/auth/login`);
  console.log(`ğŸ‘¤ Register: POST http://localhost:${PORT}/api/auth/register`);
  console.log(`ğŸ” Filters: GET http://localhost:${PORT}/api/test-cases/filters`);
  console.log(`ğŸ‘¥ Pending Users: GET http://localhost:${PORT}/api/users/pending`);
  console.log(`âœ… Approve User: PUT http://localhost:${PORT}/api/users/:id/approve`);
  console.log(`âŒ Reject User: PUT http://localhost:${PORT}/api/users/:id/reject`);
  console.log(`ğŸ”„ Update Role: PUT http://localhost:${PORT}/api/users/:id/role`);
  console.log('');
  console.log('ğŸ“‹ Permission Management:');
  console.log(`ğŸ” My Requests: GET http://localhost:${PORT}/api/permissions/my-requests`);
  console.log(`ğŸ“¥ Pending Approvals: GET http://localhost:${PORT}/api/permissions/pending-approvals`);
  console.log(`ğŸ“¤ Request Permission: POST http://localhost:${PORT}/api/permissions/request`);
  console.log(`âœ… Approve Request: PUT http://localhost:${PORT}/api/permissions/:id/approve`);
  console.log(`âŒ Deny Request: PUT http://localhost:${PORT}/api/permissions/:id/deny`);
  console.log('');
  console.log('ğŸ”” Notifications:');
  console.log(`ğŸ“¬ Get Notifications: GET http://localhost:${PORT}/api/notifications`);
  console.log(`âœ“ Mark as Read: PUT http://localhost:${PORT}/api/notifications/:id/read`);
  console.log(`âœ“ Mark All Read: PUT http://localhost:${PORT}/api/notifications/mark-all-read`);
  console.log(`ğŸ—‘ï¸ Delete Notification: DELETE http://localhost:${PORT}/api/notifications/:id`);
  console.log('');
  console.log('ğŸ“œ Audit Trail:');
  console.log(`ğŸ“Š Get Audit Log: GET http://localhost:${PORT}/api/audit-log`);
  console.log('================================');
  console.log('âœ… Ready to accept requests!');
  console.log('');
  console.log('Demo Login Credentials (Pre-approved):');
  console.log('- Username: demo-user, Password: password123 (Senior QA)');
  console.log('- Username: qa-lead, Password: lead123 (QA Lead)');
  console.log('- Username: junior-qa, Password: junior123 (Junior QA)');
  console.log('- Username: project-manager, Password: pm123 (Project Manager)');
  console.log('');
  console.log('ğŸ” User Approval System:');
  console.log('- New registrations require approval by QA Lead or Project Manager');
  console.log('- Leads and Project Managers can approve/reject users');
  console.log('- Role changes can be made by Leads and Project Managers');
  console.log('- Approval workflow tracks all changes with audit trail');
  console.log('');
  console.log('ğŸ” Permission System:');
  console.log('- Users can request edit/delete permissions for test cases they don\'t own');
  console.log('- Test case owners receive notifications and can approve/deny requests');
  console.log('- All permission changes are tracked in the audit log');
});
